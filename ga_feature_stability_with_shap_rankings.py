# -*- coding: utf-8 -*-
"""GA_Feature_Stability_With_SHAP_Rankings.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z9vX0vs9P30iVYlMyrWkEPr-ngvyiNxw
"""

# Mount google drive at /content/drive
from google.colab import drive
drive.mount('/content/drive')

!pip uninstall -y scikit-learn
!pip install scikit-learn==1.3.1
!pip install sklearn-genetic-opt

# Set seeds
import numpy as np
import tensorflow as tf
from sklearn.preprocessing import StandardScaler
import json
import pandas as pd
np.random.seed(42)
tf.random.set_seed(42)

# Read the contents of the first file
with open('/content/drive/MyDrive/BDDF_Research/approved_updated_proteins.txt', 'r') as file1:
    content1 = file1.read().splitlines()

# Read the contents of the second file
with open('/content/drive/MyDrive/BDDF_Research/investigational_proteins.txt', 'r') as file2:
    content2 = file2.read().splitlines()

# Combine the contents of both files and remove duplicates
merged_content = sorted(set(content1 + content2))

# Write the merged content to a new file
with open('merged.txt', 'w') as merged_file:
    for line in merged_content:
        merged_file.write(line + '\n')

print("Files merged successfully into 'merged.txt'.")

# Fetching PCP properties of druggable and non-druggable proteins
data_file_path = "/content/drive/MyDrive/protein_props.json"
druggable_proteins_file_path = "/content/drive/MyDrive/BDDF_Research/merged.txt"
approved_druggable_proteins_file_path = "/content/drive/MyDrive/BDDF_Research/approved_updated_proteins.txt"

with open(data_file_path, 'r') as f:
    protein_data = json.load(f)

print("Total number of uniprot human verified proteins:", len(protein_data))

with open(druggable_proteins_file_path, 'r') as f:
    druggable_proteins = f.read().splitlines()

with open(approved_druggable_proteins_file_path, 'r') as f:
    approved_druggable_proteins = f.read().splitlines()

print("Number of druggable proteins:", len(druggable_proteins))
print("Number of approved druggable proteins:", len(approved_druggable_proteins))

properties = (pd.read_json("/content/drive/MyDrive/protein_props.json")).transpose()
is_druggable = [1 if i in druggable_proteins else 0 for i in properties.index]
is_approved_druggable = [1 if i in approved_druggable_proteins else 0 for i in properties.index]

properties["is_druggable"] = is_druggable
properties["is_approved_druggable"] = is_approved_druggable

PCP_properties = properties.copy()
amino_acids = 'ACDEFGHIKLMNPQRSTVWY'
amino_acid_percent = {i:[] for i in amino_acids}
for i in PCP_properties['Amino Acid Percent']:
  for aa in amino_acids:
    amino_acid_percent[aa].append(i[aa])
for aa in amino_acids:
  PCP_properties = pd.concat([PCP_properties, pd.Series(amino_acid_percent[aa], index = PCP_properties.index, name = f"Amino Acid Percent {aa}")], axis = 1)

PCP_properties[f"Molar Extinction Coefficient 1"] = pd.Series([x[0] for x in PCP_properties['Molar Extinction Coefficient']], index = PCP_properties.index)
PCP_properties[f"Molar Extinction Coefficient 2"] = pd.Series([x[1] for x in PCP_properties['Molar Extinction Coefficient']], index = PCP_properties.index)

PCP_properties[f"Secondary Structure helix"] = pd.Series([x[0] for x in PCP_properties['Secondary Structure']], index = PCP_properties.index)
PCP_properties[f"Secondary Structure turn"] = pd.Series([x[1] for x in PCP_properties['Secondary Structure']], index = PCP_properties.index)
PCP_properties[f"Secondary Structure sheet"] = pd.Series([x[2] for x in PCP_properties['Secondary Structure']], index = PCP_properties.index)

PCP_properties.drop(columns = ['Amino Acid Count','Amino Acid Percent',"Molar Extinction Coefficient","Flexibility","Secondary Structure",'Sequence'], inplace = True)
PCP_properties['Sequence Length'] = PCP_properties['Sequence Length'].astype(int)
PCP_properties[['Molecular Weight', 'GRAVY', 'Isoelectric Point', 'Instability Index', 'Aromaticity', 'Charge at 7']] = PCP_properties[['Molecular Weight', 'GRAVY', 'Isoelectric Point', 'Instability Index', 'Aromaticity', 'Charge at 7']].astype(float)

with open("/content/drive/MyDrive/BDDF_Research/gdpc_encodings.json", 'r') as file:
    data = json.load(file)
gpdc_encodings = pd.DataFrame(data).transpose()

ppi = pd.read_json("/content/drive/MyDrive/ppi.json").transpose()
ppi_network = pd.read_csv("/content/drive/MyDrive/BDDF_Research/ppi_network_properties.csv")
ppi_network.index = ppi_network['Unnamed: 0']
ppi_network.drop(columns = ['Unnamed: 0'], inplace = True)
ppi = pd.concat([ppi, ppi_network], axis = 1)

glycolisation = pd.read_csv("/content/drive/MyDrive/glycosylation.csv")
glycolisation.index = glycolisation['Unnamed: 0']
glycolisation.drop(columns = ['Unnamed: 0'], inplace = True)
ptm = pd.read_csv("/content/drive/MyDrive/PTM_counts.csv")
ptm.index = ptm["Unnamed: 0"]
ptm.drop(columns = ['Unnamed: 0'], inplace = True)
ptm_counts = pd.concat([ptm, glycolisation], axis = 1)

with open("/content/drive/MyDrive/subcellular_locations2.json", 'r') as file:
    data = json.load(file)
unique_groups = set()
for entry in data.values():
    if "general" in entry:
        for general_entry in entry["general"]:
            if "group" in general_entry: unique_groups.add(general_entry["group"])

unique_groups_list = list(unique_groups)

rows = []
for protein_id in PCP_properties.index:
    row = {group: 0 for group in unique_groups_list}
    if protein_id in data:
        for entry in data[protein_id].get("general", []):
            if "group" in entry and entry["group"] in unique_groups:
                row[entry["group"]] = 1
    row["protein_id"] = protein_id
    rows.append(row)

subcellular_data = pd.DataFrame(rows).set_index("protein_id")

domains = pd.read_csv("/content/drive/MyDrive/BDDF_Research/data_top20_updated.csv")
domains.index = domains['Unnamed: 0']
domains.drop(columns = ['Unnamed: 0'], inplace = True)

flexibility = pd.read_csv("/content/drive/MyDrive/BDDF_Research/flexibility_properties.csv")
flexibility.index = flexibility['Unnamed: 0']
flexibility.drop(columns = ['Unnamed: 0'], inplace = True)

latent_data = pd.read_csv("/content/drive/MyDrive/BDDF_Research/latent_values.csv").transpose()
latent_data.columns = [f"Latent_Value_{i+1}" for i in latent_data.columns]
final_data = pd.concat([PCP_properties,gpdc_encodings, ptm_counts, ppi, subcellular_data, domains, flexibility, latent_data], axis = 1).dropna()
features_list = final_data.columns
y = final_data['is_approved_druggable']
features_list = features_list.drop(['is_druggable','is_approved_druggable'])
features_list = list(features_list)
print(features_list)
print(len(features_list))

estimator_0_features = np.array([True, True, False, True, False, False, True, False, True, False, False, True, True, True, True, False, True, True, True, False, False, True, True, False, True, True, False, False, True, False, True, True, False, False, False, True, False, True, False, False, False, False, False, False, False, False, False, True, True, False, False, False, False, True, True, True, False, True, True, True, False, False, False, False, False, True, True, False, True, False, True, True, False, False, False, False, False, False, True, True, False, True, False, False, True, True, True, True, False, False, True, False, False, False, False, False, False, True, False, True, False, True, False, False, False, False, True, True, True, True, True, True, True, True, False, False, True, False, False, False, False, False, True, True, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, False, True, False, True, True, True, False, True, False, False, False, True, True, True, False, False, True, False, True, True, True, False, True, False, True, False, True, True, False, True, False, True, False, True, True, True, True, False, False, False, True, True, False, False])
estimator_1_features = np.array([False, True, True, True, False, False, True, False, True, True, False, False, True, False, True, False, False, True, False, False, True, True, True, False, False, False, True, False, True, False, False, True, True, True, True, False, True, False, True, False, True, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, True, False, True, True, True, False, True, True, False, False, True, False, False, False, False, True, True, False, True, True, False, True, False, True, False, True, True, True, False, True, True, True, False, True, False, False, False, True, False, True, False, True, True, True, False, False, True, True, False, True, True, True, True, False, True, True, True, False, True, True, True, True, True, True, True, False, False, True, False, False, True, True, True, False, False, False, True, False, True, True, True, True, False, False, False, False, True, True, False, True, False, False, True, False, True, True, False, False, False, False, False, False, True, False, False, True, False, False, True, False, True, False, False, True, False, True, True, False, True, False, True, False, True, True, False, False])
estimator_2_features = np.array([True, True, True, True, True, True, False, False, False, True, False, False, True, False, False, True, False, True, True, False, True, True, True, True, False, False, False, True, False, True, False, False, False, True, False, False, False, False, True, True, True, True, True, True, False, True, True, True, True, True, True, True, False, False, True, True, False, True, False, True, False, False, False, False, True, False, False, False, False, False, True, True, True, False, True, False, True, True, False, True, False, True, True, True, True, False, True, True, True, False, False, True, True, True, False, True, False, True, True, False, True, False, False, True, False, True, False, False, False, True, False, True, True, True, False, True, True, True, False, False, True, True, False, True, True, True, False, False, True, True, True, True, False, False, True, True, False, False, True, True, True, False, True, True, True, False, True, False, True, True, True, True, False, True, True, False, False, False, True, True, True, True, True, False, True, True, True, False, True, True, True, True, True, True, False, False, True, True, False, True, False, True, True])
estimator_3_features = np.array([False, True, True, True, True, True, False, True, True, True, False, False, False, False, True, False, True, True, False, False, False, False, True, False, True, False, True, True, True, True, False, True, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, True, False, True, False, True, True, True, False, True, True, True, True, True, False, True, True, False, False, True, True, True, True, False, False, True, True, True, False, False, True, True, False, True, True, False, True, True, True, False, False, True, True, True, True, True, False, False, True, True, True, False, True, False, True, True, False, True, True, False, True, False, True, True, True, True, True, False, True, True, True, False, True, True, False, False, False, True, False, True, True, True, True, False, True, True, False, True, False, True, True, True, True, True, False, True, True, True, False, False, True, True, False, False, True, True, False, True, True, True, True, False, False, True, False, True, False, False, False, True, False, False, True, True, True, True, True, True, False, True, True, True, False, False, True, True, True])
estimator_4_features = np.array([True, True, True, True, False, False, True, True, True, False, False, True, True, False, True, True, True, True, False, True, False, False, False, False, True, True, False, True, True, True, True, False, False, False, False, False, True, True, False, False, True, False, False, False, False, False, False, True, False, False, False, False, False, True, True, False, True, True, True, True, False, True, False, True, False, False, True, True, True, True, False, True, True, False, True, False, False, False, True, True, False, False, False, True, True, True, True, True, True, True, False, False, True, False, False, True, False, True, False, False, True, False, True, True, False, False, False, True, True, True, True, True, False, False, True, False, True, True, False, True, False, True, False, True, False, True, False, True, False, True, False, True, False, False, False, False, False, True, False, False, False, True, True, True, False, False, False, False, True, False, False, True, False, True, True, True, True, True, False, False, True, False, True, False, False, True, True, False, True, False, True, False, False, False, True, False, True, False, True, True, False, True, False])
estimator_5_features = np.array([True, True, True, False, False, True, False, True, True, True, True, False, False, True, True, True, False, False, True, True, True, True, True, False, True, True, False, True, False, False, True, False, True, True, True, False, True, True, True, False, False, True, False, True, False, True, True, False, False, False, True, True, True, True, True, True, True, True, False, True, True, True, False, False, False, True, True, True, True, False, True, False, True, True, False, True, True, True, True, False, True, True, True, True, True, False, False, False, False, False, True, False, False, False, False, True, True, True, False, True, True, False, False, False, False, True, True, True, True, False, False, False, True, True, True, False, False, True, False, False, False, True, True, False, False, False, False, False, False, True, True, True, True, False, True, True, False, False, True, False, False, True, True, True, True, False, False, False, False, False, False, True, False, False, False, True, True, False, False, False, False, True, False, True, True, True, True, True, True, True, True, False, False, False, False, False, True, True, True, False, False, True, True])
estimator_6_features = np.array([False, True, False, False, True, False, False, True, False, True, True, True, True, True, False, False, True, False, False, True, True, True, False, False, False, False, False, False, True, True, True, True, True, False, False, False, False, True, False, True, False, True, True, True, True, True, False, False, True, False, True, True, False, True, True, True, True, True, True, True, False, False, False, True, True, True, True, False, True, True, False, True, False, False, True, False, True, True, True, True, False, True, False, True, True, True, False, True, True, False, True, True, True, False, True, False, False, True, False, True, True, False, False, False, True, False, True, False, True, True, True, True, False, True, False, True, True, False, False, False, False, True, False, True, False, False, True, True, False, False, True, True, False, True, False, True, True, True, True, True, True, False, False, True, True, True, False, True, True, True, True, True, False, True, True, True, True, False, False, False, False, True, True, False, False, True, True, False, True, False, True, True, True, True, False, True, False, False, False, False, False, True, False])
estimator_7_features = np.array([True, True, False, True, True, True, False, False, True, True, True, False, False, True, False, False, False, False, False, True, True, False, False, True, False, True, False, True, True, True, False, True, True, False, True, False, False, False, True, False, False, False, False, False, False, False, True, True, False, True, True, True, False, False, True, True, True, True, False, True, True, False, False, True, True, True, False, True, False, True, True, False, True, False, False, False, True, False, True, True, False, True, True, True, False, False, True, True, False, False, True, True, False, False, False, False, True, False, False, True, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, True, True, False, False, True, False, True, True, True, True, False, True, False, True, False, False, False, True, True, True, False, True, True, True, False, True, False, True, True, True, False, True, True, True, True, False, True, False, True, True, False, True, True, False, False, False, False, True, True, False, False, False, False, True, False, False, False, False, True, False, False])
estimator_8_features = np.array([False, True, True, True, True, False, True, False, True, True, False, True, True, False, False, False, False, False, True, False, True, True, False, True, False, True, True, False, True, False, False, True, True, True, False, True, True, False, False, False, True, False, True, False, True, True, True, False, True, True, True, False, True, False, True, True, True, True, False, True, False, True, False, True, False, True, True, True, False, True, True, False, False, True, False, True, True, True, True, True, True, False, True, False, True, False, True, True, False, False, True, True, False, False, True, True, False, False, True, False, False, False, False, True, False, False, False, False, False, False, False, True, False, False, True, True, True, True, False, False, False, False, False, True, True, False, False, False, True, False, False, True, False, True, False, False, True, False, True, True, False, False, True, True, False, True, False, True, True, True, False, True, False, False, False, True, True, True, True, True, True, True, False, False, True, False, False, True, False, True, False, False, True, False, False, False, True, True, False, False, True, False, True])

okk = [estimator_0_features,estimator_1_features,estimator_2_features,estimator_3_features,estimator_4_features, estimator_5_features, estimator_6_features, estimator_7_features, estimator_8_features]
shap_features = [
    "protein kinase",
    "Secondary Structure sheet",
    "Modified residue",
    "Glycosylation",
    "Disulfide bond",
    "Instability Index",
    "cell membrane",
    "xeno_experimental_count",
    "mitochondrion",
    "aromatic_aliphatic",
    "Mean",
    "GRAVY",
    "Median",
    "aromatic_negative",
    "Amino Acid Percent Q"
]


# Convert to np.array for boolean indexing
features_array = np.array(features_list)

# Your estimators' boolean feature masks stored in a list
shap_features_set = set(shap_features)  # faster lookup

for i, mask in enumerate(okk):
    selected_features = features_array[mask]
    # Find intersection with shap_features
    overlap = [f for f in selected_features if f in shap_features_set]
    total_selected = len(shap_features)
    total_overlap = len(overlap)
    total_percent = (total_overlap / total_selected) * 100 if total_selected > 0 else 0
    print(f"Estimator {i}:")
    print(f"Overlapping shap features ({total_overlap}): {overlap}")
    print(f"Total percent overlap: {total_percent:.2f}%\n")